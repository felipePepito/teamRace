\documentclass[12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, left=2.5cm, right=3cm, top=2cm]{geometry}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{ngerman}
\usepackage{amssymb}
\usepackage{setspace}
\usepackage{natbib}

\usepackage{listings,xcolor}
\usepackage{inconsolata}

\usepackage{hyperref}
\usepackage{url}

\definecolor{dkgreen}{rgb}{0,.6,0}
\definecolor{dkblue}{rgb}{0,0,.6}
\definecolor{dkyellow}{cmyk}{0,0,.8,.3}

\lstset{
  language        = php,
  basicstyle      = \small\ttfamily,
  keywordstyle    = \color{dkgreen},
  stringstyle     = \color{red},
  identifierstyle = \color{dkgreen},
  commentstyle    = \color{gray},
  emph            =[1]{php},
  emphstyle       =[1]\color{black},
  emph            =[2]{if,and,or,else, for, endif, endfor},
  emphstyle       =[2]\color{dkblue}
}
  
  
\bibliographystyle{alpha}  
\setstretch {1.433}

\setcounter{secnumdepth}{5}

\title{Ausarbeitung\bigskip\\
Praktikum praktische Programmierung\bigskip\\
\textbf{Projekt Teamrace}\bigskip\\
\large Betreuung: Martin Hofmann, Thomas Rau}

\author{Philipp Strobl\\Matrikelnummer 2554775\\
ph.strobl@gmx.de\\
Kraillinger Weg 10\\
81241 München}
\date{München, 25. Juli 2014}

\usepackage{graphicx}
\begin{document}

\maketitle
\pagebreak

\tableofcontents 


% ***** chapter 1 *****
\chapter{Zielsetzung}

\section{Definition des Begriffs 'Teamrace'}

Der Name „Teamrace“ ist aus dem sportlichen entlehnt, er bezeichnet ursprünglich eine Team-orientierte Variante der Segelregatta. 
\cite{wiki:TeamRacing} Die Grundidee des „Teamrace“ liegt im Bilden von Schüler-Teams, welche über einen längeren Zeitraum unterschiedliche Aufgaben bearbeiten und an Wettbewerben in verschiedenen Fächern teilnehmen sollen.

So ist es zum Beispiel möglich, eine Klasse in mehrere Teams einzuteilen. Die Teams nehmen im Verlauf des Teamrace an unterschiedlichen Wettbewerben teil, wie z.B. an Vokabeltests, einem Basketballturnier, einer gemeinschaftlich erarbeiteten Präsentation oder Ähnlichem. Jeder Wettbewerb wird über eine maximal erreichbare Punktzahl entsprechend gewichtet. Die erreichte Punktzahl in jedem Wettbewerb summiert sich schließlich zu einer Gesamtwertung.

\section{Zielsetzung im Rahmen des Praktikums}
Ziel des Projekts ist das Erstellen eines Softwaresystems, das die zentrale Datenverwaltung des Teamrace ermöglicht. Über eine Webapplikation soll eine Schnittstelle geschaffen werden, die es den Beteiligten in ihren unterschiedlichen Rollen ermöglicht, auf die Daten des Teamrace zuzugreifen, Details zu den Wettbewerben und den einzelnen Teams einzusehen sowie sich über die Wettbewerbe auszutauschen. Den Schülern soll hier auch die Möglichkeit gegeben werden, ihr Team in geeigneter Form online zu präsentieren. 


Konkret soll die Webapplikation also folgende Funktionalität bieten:\\
Alle Beteiligten sollen sich in der Applikation registrieren und anmelden können. Es soll den Beteiligten die Möglichkeit gegeben werden, sich mit Hilfe eines Nachrichtensystems auszutauschen. Über eine Suchmaske kann sowohl nach anderen Personen, als auch nach Teamraces gesucht werden. Zu einem bereits existierenden Teamrace kann die Aufnahme beantragt werden. Jede Person kann ein neues Teamrace erstellen und wird folglich zum Administrator des Teamrace. Der Administrator kann weitere Personen zu dem Teamrace hinzufügen, entweder in der Rolle eines Spielers, also eines normalen Teilnehmers, oder in der Rolle eines Tutors. Auch kann er Personen wieder aus dem Teamrace entfernen. Sowohl der Administrator, als auch die Tutoren können neue Wettbewerbe erstellen. Jeder Wettbewerb hat einen Namen, eine Beschreibung, eine maximal zu erreichende Anzahl an Punkten, sowie ein Datum, an dem der Wettbewerb stattfindet. 

Der Administrator kann Teams erstellen und jedes Mitglied einem Team zuordnen. Ab dem Zeitpunkt des Wettbewerbs können der Administrator und die Tutoren die von jedem Team erreichte Punktzahl festsetzen. Die Punktzahlen jedes Teams zu jedem Wettbewerb sowie der Zwischen- bzw. Endstand können von allen Mitgliedern eingesehen werden.

Der Administrator sowie die Tutoren können über einen Blog Mitteilungen an alle Mitglieder verfassen.

Vorneweg sei an dieser Stelle erwähnt, dass die hier aufgestellten Anforderungen an die Software den zeitlichen Rahmen des Projekts gesprengt haben. Daher habe ich in der Entwicklung im Rahmen des Praktikums versucht, die grundlegende Funktionalität der Software zu implementieren, um weitere Module im späteren Verlauf integrieren zu können. Insofern wurden das Nachrichtensystem, die Suche nach Personen und Teamraces, die Möglichkeit, die Mitgliedschaft bei bestehenden Teamraces zu beantragen sowie insgesamt die Rolle des Tutors nicht implementiert.



% ***** chapter 2 *****
\chapter{Lösungsmöglichkeiten}

\section{Programmiersprachen für Webapplikationen}
\label{sec:Programmiersprachen}
\subsection{PHP}
PHP ist eine Server-seitige Skriptsprache, die besonders für die Anwendungsentwicklung im World Wide Web entwickelt wurde, jedoch auch für andere Zwecke einsetzbar ist.

Die hohe Verbreitung von PHP ist unter anderem darauf zurückzuführen, dass PHP die Vermischung von HTML und PHP Code im Quelltext, was die Gestaltung von dynamischen Internetseiten auch für Anfänger sehr einfach macht. PHP Code wird von einem Interpreter ausgeführt, der als Modul in den Webserver integriert ist (z.B. php5\_module unter Apache), oder als CGI Anwendung.

Seit der Version 5 ist PHP eine objektorientierte Sprache. Auch wenn bei der Funktionsdefinition ein fester Typ von Übergabeparametern gefordert werden kann, ist PHP generell dynamisch typisiert. PHP ist freie Software und wird von den meisten Webservern und auf fast allen Plattformen und Betriebssystemen unterstützt.(\cite{ebooks:PHP}, \cite{ebooks:PHP2}, \cite{PHPManual})

\subsection{Ruby}
So wie PHP ist auch Ruby eine dynamisch typisierte sprache, jedoch keine Skriptsprache. Beliebte Compiler sind JRuby and Rubinius. Ruby hebt sich in seinem Syntax teilweise deutlich von C, Java oder PHP ab, insofern z.B. Blöcke nicht durch Klammern, sondern durch Schlüsselwörter markiert werden. (\cite{Ruby}, \cite{wiki:Ruby})

Zur Programmierung von Webanwendungen erfreut sich das Framework "'Ruby on Rails"' hoher Popularität (\cite{RubyOnRails}).

\subsection{Java (Enterprise Edition)}
Die sprachlichen Eigenschaften von Java seien hier nicht erwähnt, insofern sie im verlauf des Studiums genügend diskutiert werden.

Für die Entwicklung von Webapplikationen gibt es eine Reihe von Java Technologien, die standardisiert und in unterschiedlicher Weise implementiert wurden. Jene standardisierten technischen Spezifikationen sind unter dem Deckmantel "'Java Enterprise Edition"' \cite{JavaEE} zusammengefasst, sie werden im Rahmen des "'Java Community Process"' \cite{JavaCommunityProcess} entwickelt.

Für den Application Server existieren mehr als 10 unterschiedliche Java EE 6 konforme Implementierungen. Als Vorteil ist zu nennen, dass Webapplikationen auf Basis von Java EE sehr skalierbar und variabel sind, daraus ergibt sich aber entsprechend eine hohe Komplexität und Hürde im Einstieg in der Programmierung von Webanwendungen. (\cite{eberling2007enterprise}, \cite{mueller2010javaserver})

\subsection{Im Projekt verwendete Sprache}

Ausgangspunkt für die Entwicklung war die Entscheidung für PHP als Programmiersprache. Gegen die Entwicklung mit Ruby habe ich mich schlicht deswegen entschieden, weil ich keinerlei Erfahrung mit der Sprache habe und mir der Syntax sehr unübersichtlich erscheint. Eine Entwicklung mit Java habe ich lange in Betracht gezogen. Nach eingehendem Studium von Fachbüchern zu dem Thema wurde mir jedoch klar, dass die Vielzahl an Möglichkeiten, die die Verwendung von Java Enterprise Edition mit ihren Komponenten bietet, auch mit einer entsprechenden Komplexität einhergeht. Insofern habe ich mich schließlich gegen diese Alternative entschieden, da ich der Einschätzung war, die Software damit nicht in dem zeitlichen Rahmen des Praktikums entwickeln zu können.

\section{Frameworks für Webapplikationen}
\label{sec:Frameworks}
Webframeworks sind selbst für die Programmierung von kleinen Webseiten, die nicht ausschließlich statische Inhalte präsentieren, von großer Bedeutung. Sie stellen im Üblichen die folgende Infrastruktur und Funktionalität für die Entwicklung zur Verfügung:

\begin{itemize} 
\item Validierung der eingehenden und Filterung der ausgehenden Informationen 
\item Authentifizierung und Autorisierung von Benutzern
\item Zugriff auf Datenbanken, Datenbankenkonfiguration und Object-Relational Mapping
\item URL Mapping (Entkopplung der URLs von der Applikationslogik)
\item Templating (Mechanismen zur einfachen Integration von Daten in den HTML-Output
\item Internationalisierung
\item Tests
\item Caching
\end{itemize}

Auf die einzelnen Punkte wird im weiteren Verlauf der Ausführung bei der Dokumentation der einzelnen Komponenten der Software noch näher eingegangen.

Es existieren eine Reihe von unterschiedlichen Frameworks für PHP, z.B. CakePHP oder Yii, die jedoch alle die oben genannten Grundfunktionalitäten bieten. Für das Symfony 2 Framework habe ich mich entschieden, da es in seiner Entwicklung und Architektur sehr ausgereift ist, eine innovative Templating-Engine (Twig) besitzt, eine hohe Flexibilität gewährleistet und gut dokumentiert ist.
(\cite{PHPFrameworksComparision}, \cite{wiki:FrameworksComparision})




% ***** chapter 3 *****
\chapter{Dokumentation der Entwicklung}
Im Folgenden soll die Entwicklung der Software in Verbindung mit den zugrunde liegenden technischen und konzeptionellen Hintergründen dargestellt werden. Zur besseren Lesbarkeit wird versucht, beides möglichst flüssig ineinander zu integrieren.

\section{Einführung in die Architektur des Symfony Frameworks}
Für die Erläuterung des Aufbaus der Software ist ein grober Überblick über die Architektur und Strukturierung des Symfony Frameworks nötig. In Symfony ist das Entwicklungsprinzip "'Seperation of Concerns"' von grundlegender Bedeutung. Alle Komponenten sind unabhängig voneinander und auch in entkoppeltem Zustand zu verwenden.

\subsection{Model View Control}
Grundmotivation hinter dem Strukturmuster "'Model View Controller"' ist die Entkopplung der Darstellung der Informationen von ihrer Aufbereitung. Hierzu werden die Verantwortlichkeiten innerhalb der Software auf die Darstellung (View), die Verwaltung der Daten (Model) sowie die Verbindung der Darstellung mit den Daten und der Benutzerschnittstelle (Controller) aufgeteilt.\cite{MVC}

Symfony bedient sich dem Muster, dabei sind die einzelnen Komponenten untereinander auch austauschbar. So gibt es zwei unterschiedliche ORM Implementierungen (Doctrine und Propel), die verwendet werden können.

\begin{figure}[htp]
\centering
\includegraphics[scale=0.5]{Bilder/MVC-Process.jpg}
\caption{Einfache schematische Darstellung des MVC Patterns}
\label{}
\end{figure}

\subsection{Front Controller}
Der Front Controller vereinigt bzw. bündelt alle Anfragen an die Anwendung, um sie anschließend an die entsprechende Bestimmung weiterzuleiten. Dies hat den Vorteil, dass für in vielen Anfragen wiederkehrende Aufgaben (z.B. Authentifizierung, Internationalisierung) nicht auf viele Objekte verteilt wird, sondern im Front Controller einheitlich abgearbeitet werden.
\cite{FrontController}

In Symfony Applikationen werden alle Anfragen an eine php-Datei geleitet, die im Normalfall mit \emph{app.php} benannt ist. Mittels Umbenennungsregeln seitens des Webservers (z.B. RewriteRule in Apache) wird erreicht, dass dies für den Nutzer im Normalfall nicht erkennbar ist. Hier wird eine Instanz des AppKernel Objekts generiert und ggf. dekoriert (z.B. mit dem einem HTTP Cache, wobei dann das \emph{AppKernel} Objekt von einem \emph{AppCache} Objekt umhüllt wird). 

Weiter wird aus den Komponenten des Requests, die in PHP in globalen Variablen gespeichert sind (z.B. \emph{\$\_GET, \$\_POST, \$\_COOKIE}) ein Request Objekt geformt und dem AppKernel übergeben. Der AppKernel ist eine Unterklasse des Kernel, welcher den Kern der Anwendung darstellt. Hier werden alle Komponenten der Anwendungen (auch genannt \emph{Bundle}, z.B. die Templating-Engine \emph{Twig} oder das ORM Bundle \emph{Doctrine}) erzeugt und mit der Konfiguration versehen. Dies geschieht, indem die von dem Kernel Objekt nicht implementierten Methoden \emph{registerBundles} und \emph{registerContainerConfiguration} im AppKernel implementiert werden.

Symfony bietet darüber hinaus die Möglichkeit, die gleiche Applikation in verschiedenen Umgebungen zu betreiben, z.B. in einer Entwicklungsumgebung und einer Produktionsumgebung. Hierdurch ändert sich z.B. das Verhalten der Anwendung im Fehlerfall, so wird in der Entwicklungsumgebung ein Stacktrace und eine möglichst präzise Beschreibung des Fehlers wiedergegeben, während jene Informationen im Produktionsbetrieb aus Aspekten der Sicherheit natürlich möglichst vor dem Nutzer verborgen werden sollen. Technisch wird dies dadurch realisiert, dass mehrere Front Controller existieren, die bei der Erzeugung des AppKernels jeweils unterschiedliche Konfigurationsdateien und Komponenten laden.
(\cite{sf2:FrontController})

\subsection{Routing}

\begin{figure}[htp]
\centering
\includegraphics[scale=0.7]{Bilder/request-flow.png}
\caption{Schematische Darstellung der Verarbeitung von Anfragen \cite{sf2:HTTPFundamentals}}
\label{fig:RequestFlow}
\end{figure}
In der Grafik \ref{fig:RequestFlow} ist eine Komponente mit Namen "'Routing"' zu erkennen. Sie sorgt dafür, dass jede Anfrage an den jeweils zugehörigen Controller weitergeleitet wird. Dies wird umgesetzt, indem die URL des Requests mit den Einträgen in den Routing-Tabellen der Applikation verglichen wird. Technisch besteht das Routing aus 3 Teilen: 

\begin{itemize}
\item{Einer \emph{RouteCollection}, die die Definitionen der einzelnen Routen enthält. Jede Definition ist dabei eine Instanz der Klasse \emph{Route}}.
\item{Einem \emph{RequestContext}, der die Parameter des Requests enthält. Üblicherweise wird er direkt aus dem vom Front Controller übergebenen \emph{Request} Objekt gespeist.}
\item{Einem \emph{UrlMatcher}, welchem bei der Konstruktion die \emph{RouteCollection} übergeben wird, und diese anschließend bei Bedarf nach Übereinstimmung mit einem \emph{RequestContext} zu durchsuchen.}
\end{itemize}

Im Fall einer gefundenen, passenden Route wird der Name des Controllers sowie der Name der Route zurück an den Kernel übergeben, andernfalls wirft der Router eine entsprechende Exception.(\cite{sf2:RoutingComponent})\\

Die \emph{RouteCollection} wird üblicherweise aus entsprechenden Konfigurationsdateien generiert. Wie für alle Konfigurationsdateien bietet Symfony hier die Dateiformatsoptionen \emph{yml} und \emph{xml}. Auch eine Generierung über Annotationen in den Controllern ist möglich. Im beschriebenen Projekt habe ich mich für das \emph{xml} Format entschieden. Folgendes Listing zweigt beispielhaft die Definition einer Route:

\begin{lstlisting}[language=PHP, caption=Auszug aus\\ src/TeamRace/WebBundle/Resources/config/routing.xml]
  <route id="teamraceHome" pattern="/{_locale}/teamrace/{idTeamrace}">
    <default key="_controller">TeamRaceWebBundle:Teamrace:home</default>
    <requirement key="_locale">en|de</requirement>
  </route>
  
\end{lstlisting}
  
Im vorliegenden Pattern sind zwei unterschiedliche Platzhalter erkennbar: \emph{\_locale} und \emph{idTeamrace}. Für den Platzhalter \emph{\_locale} wird weiterhin über das \emph{requirement} Attribut gefordert, dass er entweder dem String "'en"' oder "'de"' entspricht.

Es gibt noch weitere Möglichkeiten, Anforderungen an die Route zu stellen, z.B. die Art des HTTP-Requests (GET, POST, ..) oder der Host, an den die Anfrage gerichtet wurde. Außerdem können default-Werte für Platzhalter festgelegt werden. (\cite{sf2:Routing})\\

Im vorliegenden Beispiel wird im Falle einer Übereinstimmung des Requests mit dem geforderten URL-Pattern für die Weiterleitung an den entsprechenden Controller der String \emph{TeamRaceWebBundle:Teamrace:home} an den Kernel übergeben. Der String wird als "'Logical Controller Name"' bezeichnet. Er beinhaltet den Namen des Bundles, die Kontroller-Klasse sowie die aufzurufende Funktion innerhalb der Klasse. In diesem Projekt sind alle Controller in einem Bundle zusammengefasst, dem TeamRaceWebBundle. Die Controller-Klasse heißt im obigen Beispiel Teamrace (insofern hier eine Seite aufgerufen wird, die Daten aus einem bestimmten Teamrace wiedergibt), die aufgerufene Funktion heißt \emph{homeAction}. Jener Funktion werden, je nach Funktionsdefinition, die Werte der Platzhalter übergeben, im obigen Fall der Wert für \emph{idTeamrace}.

\subsection{Controller}
Die Aufgabe des Controllers ist es, die Anfrage in eine Antwort umzusetzen. In vielen Fällen wird er dabei Daten aus einer Datenbank (der "'Model"' Komponente im MVC Entwurfsmuster) abfragen bzw. eine Veränderung des Datensatzes vornehmen und eine Darstellung in Form von HTML-Code erzeugen, um diese als Antwort an den Client zurückzusenden.

Natürlich ist nicht in jedem Fall ein Miteinbezug eines Datenbestandes nötig, für rein statische Seiten, wie der Seiten im Projekt, die auch ohne Authentifizierung zugänglich sind (z.B. die "'home"'- oder "'about"' Seiten), ist keine Datenbankzugriff nötig.

Ebenso kann die Anforderung an eine Antwort an den Client sehr unterschiedlich ausfallen. Zum einen ist z.B. ein Redirect auf eine andere Seite als Antwort möglich, zum anderen ist gerade in modernen Webanwendungen via AJAX (siehe \ref{sec:AJAX}) oft lediglich ein Transfer von reinen Daten ohne Informationen über ihre Darstellung gefordert, wobei hier die Daten üblicherweise im json-Format übermittelt werden.\\

Technisch gesehen kann der Controller in Symfony aus jedwedem "'Callable"' bestehen, im Normalfall jedoch aus einer Methode innerhalb einer Klasse, die die Klasse \emph{Controller} beerbt. Dadurch werden innerhalb des Controllers die Funktionalität aller in die Applikation eingebundenen Komponenten verwendbar. Alternativ kann auch die \emph{ContainerAware} Klasse beerbt werden, der Unterschied besteht lediglich darin, dass die Klasse Controller einige Abkürzungen für die Verwendung von gängigen sogenannten "'Helper-Methoden"' bereitstellt. So kann z.B. zum Rendern eines Templates

\begin{lstlisting}
$this->render('TeamRaceWebBundle:External:about.html.twig');
\end{lstlisting}
statt 
\begin{lstlisting}
$this->get('templating')->renderResponse(
	'TeamRaceWebBundle:External:about.html.twig');
\end{lstlisting}
verwendet werden.

\subsection{View}

Wie oben angeführt, ist eine der Hauptaufgaben des Controllers, die Darstellung der Inhalte zu erzeugen, um diese anschließend an den Client zu senden. Im obigen Listing ist bereits zu erkennen, dass der Templating-Engine ein String übergeben wird, der auf eine Datei verweist. Die Struktur der Namensgebung ist ähnlich wie beim Logischen Controller Namen: Hier wird auf die Datei "'\emph{about.html.twig}"' verwiesen, die im Ordner "'\emph{External}"' der Ressourcen des Bundles "'\emph{TeamRaceWebBundle}"' gespeichert ist.

Generell bezeichnet der Begriff "'Template"' eine Textdatei, die mit einem entsprechenden Interpreter eine Text-basierte Datei zur Informationsdarstellung erzeugt. Mit PHP lassen sich Templates erzeugen, insofern der PHP-Interpreter die Integration von PHP Code in HTML Code erlaubt. In Symfony wird eine Templating-Engine mit Namen "'Twig"' verwendet. Twig wurde auf Grundlage von PHP entwickelt und bietet eine elegante Syntax, um Templates zu erstellen. (\cite{sf2:Templates}) 

Folgender Code, entnommen aus dem Template zur überblickshaften Darstellung der Wettbewerbe, soll der Erläuterung des Syntax dienen:
\begin{lstlisting}[language=PHP, caption=Auszug aus\\ src/TeamRace/WebBundle/Resources/views/Teamrace/challenges.html.twig, label=lst:challenges]
{% extends "TeamRaceWebBundle:Teamrace:_layout.html.twig" %}

[...]

{% for challenge in challenges %}
{% if challenge.date | date('Y-m-d-G-i') >= "now" | date('Y-m-d-G-i') %}

<div class="challengeBox">
  <div style="width:460px; float:left;">
    <a>{{ (loop.length - loop.index0) ~ '. Challenge' }}</a>
  </div>
  <div>
    {{ "Date: " | trans }}
    {{ challenge.date | date("d.m.y G:i") }}
  </div>
  <div>
    {{ challenge.description | length > 150 
      ? challenge.description | slice(0, 150) ~ '...' 
      : challenge.description }}
  </div>
</div>

{% endif %}
{% endfor %}

\end{lstlisting}


Jeder Ausdruck innerhalb eines Blocks, der von \texttt{\{\{ \}\}} umschlossen ist, wird ausgegeben. Die Logik innerhalb des Templates, wie Kontrollstrukturen und Wiederholungsanweisungen, wird innerhalb von Blöcken formuliert, die mit \texttt{\{\% \%\}} umschlossen sind.

Weiterhin gibt es Filter, die Inhalte verändern. Ein Beispiel hierfür ist die Verwendung des Filters \texttt{slice(0, 150)}, der den Inhalt der Variablen \texttt{challenge.description} auf die ersten maximal 150 Zeichen kürzt. Weiterhin werden im Beispiel die Filter \texttt{length}, der die Länge eines Strings ausgibt, \texttt{date("'d.m.y G:i"')}, der ein PHP \emph{DateTime} Objekt in einem entsprechend formatierten String ausgibt und der Filter \texttt{trans} verwendet. \texttt{trans} ist eine Funktion zur Internationalisierung, die nach Übersetzungen für Strings sucht. Mehr dazu im Kapitel \ref{sec:Internationalisierung}.

Jedes Twig Template wird zu einer nativen PHP Klasse kompiliert, welches zur Laufzeit geladen wird.\\

Elemente, die in jeder Seite wiederkehren, wie zum Beispiel die Navigation oder die HTML-Header Angaben, müssen nicht in jedem Template erscheinen. Hier kommt die sogenannte Template-Vererbung ins Spiel. Im vorliegenden Projekt haben die Templates eine zweistufige Vererbung. Das für alle Templates identische Grundgerüst enthält neben den Meta-Informationen und dem HTML-Seiten Grundgerüst die folgenden drei Blöcke:
\begin{lstlisting}[language=PHP, caption=Auszug aus app/Resources/views/TeamRace.html.twig]
<div id="navigation">
  {% block navigation %}{% endblock %}
</div>
<div id="navigationTeamrace">
  {% block navigationTeamrace %}{% endblock %}
</div>
<div id="content">
  {% block content %}{% endblock %}
</div>
\end{lstlisting}

Auf der nächsten Ebene in der Vererbungs-Hierarchie werden die Navigations-Blöcke implementiert. Diese sind in den drei Modulen der Applikation (siehe Kapitel \ref{sec:ApplikationsStruktur}) jeweils identisch: 
\begin{lstlisting}[language=PHP, caption=Auszug aus \\src/TeamRace/WebBundle/Resources/views/Teamrace/\_layout.html.twig]
{% extends '::TeamRace.html.twig' %}

{% block navigation %}
  <a id="navigationHome" href="{{ url('userHome') }}">
    {{ 'home' | trans }}
  </a>
  <span class="navigationSpacer"></span>
  [...]
{% endblock %}

{% block navigationTeamrace %}
  [...]
{% endblock %}
\end{lstlisting}

Auf der letzten Ebene der Vererbungs-Hierarchie (siehe Listing \ref{lst:challenges}) wird schließlich der Content-Block implementiert.
(\cite{Twig})

\section{Model}

In der Interpretation des MVC-Schemas, welche dem Symfony-Framework zu Grunde liegt, ist die Model-Komponente der Teil der Applikation, der für die Verwaltung und den Abruf von Persistenten Daten zuständig ist. Für Symfony ist die Verwendung von zwei unterschiedlichen Object-Relational Mapping Bibliotheken dokumentiert (Propel bzw. Doctrine), denkbar ist jedoch auch hier die Verwendung beliebiger Alternativen. Standardmäßig wird die Verwendung der Doctrine-Bibliothek empfohlen, weshalb ich diese in der Applikation verwendet habe.

\subsection{Entity Mapping}
\label{entityMapping}
 
Der Doctrine Object-Relational Mapper ist eine PHP Bibliothek, die eine Projektion von skalaren Daten, die in tabellarischer Form gespeichert sind, auf objektorientierte Daten ermöglicht. Als Beispiel sei hier die Klasse "'Blog"' dargestellt, die einen einzelnen Blogeintrag repräsentiert. Der Administrator eines Teamraces hat die Möglichkeit, über Blogeinträge aktuelle wichtige Informationen an alle Mitglieder des Teamrace weiterzugeben. Diese bestehen aus einer Überschrift, einem Text, dem Datum und der Uhrzeit der Erstellung sowie einer Referenz auf das zugehörige Teamrace.

\begin{lstlisting}[language=PHP, caption=Auszug aus src/TeamRace/WebBundle/Entity/Blog.php]
/**
 * Blog
 *
 * @ORM\Table(name="blog", indexes={@ORM\Index(name="teamrace", 
   columns={"teamrace"})})
 * @ORM\Entity
 */
class Blog
{
    /**
     * @var integer
     * @ORM\Column(name="id_blog", type="integer", nullable=false)
     * @ORM\Id
     * @ORM\GeneratedValue(strategy="IDENTITY")
     */
    private $idBlog;

    /**
     * @var string
     * @ORM\Column(name="headline", type="string", length=255, nullable=false)
     */
    private $headline;

    /**
     * @var string
     * @ORM\Column(name="text", type="text", nullable=false)
     */
    private $text;
    
     /**
     * @var \DateTime
     * @ORM\Column(name="date", type="datetime", nullable=false)
     */
    private $date;

    /**
     * @var \Teamrace
     * @ORM\ManyToOne(targetEntity="Teamrace")
     * @ORM\JoinColumns({
     *   @ORM\JoinColumn(name="teamrace", referencedColumnName="id_teamrace")
     * })
     */
    private $teamrace;
    
    [...] // Getter and Setter Methods
}
\end{lstlisting}
Im Beispiel wird sichtbar, dass den einzelnen Attributen der Klasse Blog über Annotationen Meta-Informationen beigefügt sind. Die \texttt{@var} Annotation gibt über den Typ in PHP Auskunft und ist für das ORM nicht von Bedeutung. Alle folgenden Annotationen besitzen den Namespace ORM. Annotationen als sprachliches Konstrukt sind in PHP 5.x noch nicht sehr ausgereift implementiert, daher verwendet Doctrine für die Annotationen eine eigene Bibliothek, die auf der Docblock Bibliothek aufbauen (\cite{Doctrine:BasicMapping}).\\\\ 
\texttt{@ORM\textbackslash Entity} deklariert die PHP-Klasse als Entity innerhalb einer Datenbank\\
\texttt{@ORM\textbackslash Table(name="'blog"', indexes=\{@ORM\textbackslash Index(name="'teamrace"', columns=\{"'teamrace"'\})\})} 
definiert den Namen der zur Klasse assoziierten Tabelle, das Attribut, welches den Primärschlüssel definiert sowie alle Indizes.\\
\texttt{@ORM\textbackslash Column(name="'.."', type="'.."', ..}) gibt Auskunft darüber, welchen Namen und Typ das Attribut in der referenzierten Tabelle hat und beinhaltet ggf. noch weitere Constraints (z.B. \texttt{nullable=false}).\\
\texttt{@ORM\textbackslash Id} und \texttt{@ORM\textbackslash GeneratedValue(strategy="'IDENTITY"')} definieren das Attribut als Identifizierer und legen die Strategie fest, mit der die Ids von der Datenbank generiert werden. Die hier gewählte Strategie entspricht der MySQL Option "'Auto Increment"'.\\
\texttt{@ORM\textbackslash ManyToOne(targetEntity="'Teamrace"')} definiert eine \emph{n:1} Assoziation zwischen den Entitiäten Blog und Teamrace. Die Annotation \texttt{@ORM\textbackslash JoinColumns(..)} beschreibt das referenzierte Attribut in der Tabelle Teamrace. (\cite{Doctrine:Associations})

Nicht aufgeführt sind in obigem Beispiel die Getter- und (ausgenommen für das Feld "'Id"') Setter Methoden der Entity-Klasse.\\

Weiter bietet Doctrine die Möglichkeit, das zugehörige Datenbankschema zu erstellen bzw. bei Änderungen zu überarbeiten. In obigem Beispiel wird folgender SQL-Code ausgeführt:

\begin{lstlisting}[language=sql, caption=Erzeugter SQL-Code zu obigem Beispiel]
CREATE TABLE blog (
  id_blog INT AUTO_INCREMENT NOT NULL, 
  teamrace INT DEFAULT NULL, 
  headline VARCHAR(255) NOT NULL, 
  text LONGTEXT NOT NULL, 
  date DATETIME NOT NULL, 
  INDEX Index_blog (teamrace), 
  PRIMARY KEY(id_blog)
)
ALTER TABLE blog ADD CONSTRAINT FK_Blog 
FOREIGN KEY (teamrace) REFERENCES teamrace (id_teamrace);
\end{lstlisting}

Alternativ gibt es neben Annotationen auch die Möglichkeit, die Meta-Daten der Entities in eigenen Konfigurationsdateien im xml- bzw. yml Format zu hinterlegen.


\subsection{Arbeiten mit Entity-Objekten}
\label{Transaktionen}
Wie in den gängigen ORM Libraries für Java (Hibernate, JPA), wird auch in Doctrine der Zugriff auf Daten über einen Entity-Manager realisiert. Er ist der zentrale Zugangspunkt zur ORM Funktionalität. Dadurch wird auch ein "'Transactional write-behind"' realisiert, indem einzelne, atomare Änderungen an den Entitäten zu Transaktionen zusammengefasst werden. Erst bei einem Aufruf der Methode \emph{flush()} des Entity-Managers wird eine Strategie für die Änderungen am Datenbestand erarbeitet und durchgeführt. \cite{Doctrine:Architecture}

\subsubsection{Lesender Datenzugriff}

Es gibt mehrere Möglichkeiten, Objekte aus der Datenbank abzurufen. Der schlichte Abruf eines Objekts über den Primärschlüssel sowie der Abruf eines Arrays (genauer gesagt einer ArrayCollection) von Objekten, die bestimmte Eigenschaften erfüllen, ist im folgenden Listing darstellt:

\begin{lstlisting}[language=php, caption=Auszug aus \\src/TeamRace/WebBundle/Controller/TeamraceController.php]
$this->teamrace = $this->getDoctrine()
  ->getRepository('TeamRaceWebBundle:Teamrace')
  ->find($idTeamrace);

$this->role = $this->getDoctrine()
  ->getRepository('TeamRaceWebBundle:UserTeamrace')
  ->findOneBy(array(
    'teamrace' => $idTeamrace, 
    'user' => $this->user->getIdUser()));
\end{lstlisting}

Hier ist sichtbar, dass der Abruf von Objekten aus der Datenbank immer über ein Repository geschieht. Dieses Objekt enthält alle Metadaten der Entität und stellt Methoden bereit, um den Abruf von Objekten aus der Datenbank zu realisieren.

Ersterer oben dargestellter Abruf sucht mit der Methode \texttt{find(..)} nach einem Eintrag in der Tabelle \emph{Teamrace} mit einem bestimmten Primärschlüssel. Er gibt entweder das passende Objekt oder \texttt{null} zurück.

Der zweite Abruf verlangt nach den Einträgen in der Tabelle \emph{UserTeamrace}, die in den Spalten \emph{Teamrace} und \emph{User} jeweils einen bestimmten Wert besitzen. Er gibt eine ArrayCollection aus den Bedingungen entsprechenden Objekten zurück. Eine ArrayCollection ist ein Objekt aus der Biblothek Doctrine/Common, sie kapselt ein PHP Array und erweitert es um einige Funktionen. (\cite{Doctrine:ArrayCollection})

Doctrine verwendet das sogenannte "'Lazy Loading"' und sogenannte Proxy Objekte. Sie werden benutzt, um Referenzen zu Objekten herzustellen, deren Identifier bekannt ist bzw. um Entitäten aus der Datenbank laden zu können, ohne gleichzeitig alle referenzierten Objekte laden zu müssen. Würde beispielsweise ein Blog-Eintrag aus der Datenbank ohne Lazy Loading geladen werden, müsste auch das komplette referenzierte Teamrace Objekt geladen werden. Um dies zu verhindern, wird ein stellvertretendes, "'leeres"' Teamrace Objekt erstellt. Sobald ein Zugriff auf das Teamrace Objekt erfolgt, wird es aus der Datenbank nachgeladen.\\

Eine weitere, flexiblere Methode zum Abruf von Objekten aus der Datenbank bietet die "'Doctrine Query Language (DQL)"', ein Derivat einer "'Object Query Language"', ähnlich zu ihren Pendants in Java, der "'Hibernate Query Language"' bzw. der "'Java Persistence Query Language"'.

Die DQL ist in ihrem Syntax an SQL angelehnt, arbeitet jedoch mit Objekten und ihren Attributen. Folgendes Beispiel gibt einen Einblick in den Syntax und die Funktionsweise:

\begin{lstlisting}[language=php, caption=Auszug aus src/TeamRace/WebBundle/Entity/UserTeamRepository.php, showstringspaces=false]
public function getUserAndTeams($idTeamrace) {
  $queryString = "
    SELECT userTeam, team, user
      FROM TeamRaceWebBundle:UserTeam userTeam 
      JOIN userTeam.team team
      JOIN userTeam.user user
        WHERE team IN
        (SELECT team2 
          FROM TeamRaceWebBundle:Team team2 
          JOIN team2.teamrace teamrace
            WHERE teamrace.idTeamrace = :idTeamrace)";
		
  $query = $this->getEntityManager()->createQuery($queryString);
  $query->setParameters(array('idTeamrace' => $idTeamrace));		
  return $query->getResult();
}
\end{lstlisting}
\texttt{userTeam}, \texttt{team}, \texttt{user} sind sogenannte Identifikationsvariablen, die die jeweiligen Entitätsklassen referenzieren. Über den "'."' in z.B. \texttt{userTeam.user} wird ein Attribut eines Objekts referenziert.

Der obige JOIN wird als "'Fetch Join"' bezeichnet, insofern er nicht nur die UserTeam Objekte aus der Datenbank lädt, die die gewünschten Eigenschaften erfüllen, sondern auch die referenzierten Team und User Objekte. Würde statt \texttt{SELECT userTeam, team, user} nur \texttt{SELECT userTeam} gefordert werden, würden die referenzierten User und Team Objekte nur mit den oben erwähnten Proxy Objekten versehen werden.

Schließlich fällt in obigem Beispiel noch die Zeile \texttt{WHERE teamrace.idTeamrace = :idTeamrace} ins Auge. \texttt{:idTeamrace} bezeichnet einen "'Named parameter"', der im Folgenden durch den Aufruf der Funktion \texttt{setParameters(array("'idTeamrace"' => \$idTeamrace))} gesetzt wird. (\cite{Doctrine:DQL})\\

Obiges Listing entstammt einem selbst erstellten Repository für die UserTeam Entität, welches das Standard-Repository beerbt und um die abgebildete Funktion erweitert. Durch das Setzen der Meta-Information \\
\texttt{\@ORM\textbackslash Entity(repositoryClass="'TeamRace\textbackslash WebBundle\textbackslash Entity\textbackslash UserTeamRepository"')} in der Klasse der Entität \emph{UserTeam} (siehe Kapitel \ref{entityMapping}) wird fortan automatisch die erweiterte Repository-Klasse beim Aufruf der Funktion \texttt{getRepository(..)} gewählt:
\begin{lstlisting}[language=php, caption=Auszug aus \\src/TeamRace/WebBundle/Controller/TeamraceController.php, showstringspaces=false]
// Fetch all users and the teams they participate in 
$userAndTeams = $this->getDoctrine()
  ->getRepository('TeamRaceWebBundle:UserTeam')
  ->getUserAndTeams($idTeamrace);
\end{lstlisting}

\subsubsection{Schreibender Datenzugriff}
Um neue Objekte in der Datenbank zu speichern, wird die Funktion \texttt{persist(..)} des Entity Managers, wie im folgenden Listing beispielhaft dargestellt, verwendet:
\begin{lstlisting}[language=php, caption=Auszug aus \\src/TeamRace/WebBundle/Controller/TeamraceController.php, showstringspaces=false]
$team = new Team();
[...]    	
$em = $this->getDoctrine()->getManager();
$em->persist($team);
$em->flush();
\end{lstlisting}
In ähnlicher Weise werden Daten geändert oder gelöscht. Das Löschen von Daten ist in folgendem Listing erkennbar:
\begin{lstlisting}[language=php, caption=Auszug aus \\src/TeamRace/WebBundle/Controller/TeamraceController.php, showstringspaces=false]
if (!empty($userTeamrace)) {
  $em = $this->getDoctrine()->getManager();
  $em->remove($userTeamrace);
  $em->flush();
}
\end{lstlisting}
Die Änderung von bereits in der Datenbank existieren Daten erfolgt implizit. Objekte, die aus der Datenbank abgerufen wurden, werden im Entity-Manager verwaltet, sie besitzen dabei sie den Zustand "'managed"'. Wenn diese Objekte verändert werden, wird beim nächsten Aufruf von \texttt{flush()} die Änderung in der Datenbank persistent gemacht.\\

Die Funktion \texttt{flush()} ist allgemein die Aufforderung, alle bislang in der UnitOfWork gespeicherten Datenbankoperationen innerhalb einer Transaktion durchzuführen. Jenes Verhalten und das Prinzip des "'Transactional write-behind"' wurde bereits in Kapitel \ref{Transaktionen} angesprochen.\\

Nachdem nun die übergeordnete Architektur und einige grundlegenden Komponenten des Symfony Frameworks besprochen wurden, soll im folgenden Abschnitt konkret auf die Struktur der Anwendung eingegangen werden.

\section{Grundlegende Strukturierung der Applikation}

Grundlegend gliedert sich die hier dokumentierte Webapplikation in drei Bereiche: 

Einen "'externen"' Bereich, der ohne Authentifizierung zugänglich ist. Hier sind neben rechtlichen Hinweisen (dem Disclaimer) vor allem Informationen über das Projekt und die zu Grunde liegenden Ideen zu finden. Außerdem bietet das externe Modul die Möglichkeit, sich zu registrieren, und sich anzumelden.

Einen "'Benutzerbereich"', in dem der Nutzer seine Daten einsehen und verändern, auf das Nachrichtensystem zugreifen, nach Nutzern oder Teamraces suchen, auf Teamraces zugreifen oder neue Teamraces erstellen kann.

Einen Teamrace-spezifischen Bereich. Hier findet sich die gesamte Funktionalität, um auf die Daten des Teamrace zuzugreifen oder sie anzulegen und zu verändern.

\label{sec:ApplikationsStruktur}

\subsection{Externes Modul}
Anonyme Authentifizierung
\subsubsection{Registrierung}
\subsubsection{Login}

\subsection{User Modul}

\subsection{Teamrace Modul}
\section{Internationalisierung}
\label{sec:Internationalisierung}


% ***** chapter 4 *****
\chapter{Grundlegende technische Konzepte und Problemstellungen von Webapplikationen}

Im Folgenden sollen einige grundlegende Konzepte und Problemstellungen von Webapplikationen erläutert und den im Projekt verwendeten Lösungsansätzen gegenübergestellt werden. 

\section{Session Management, Sicherheit}
Da HTTP nicht zum Aufbau längerer Sessions in der Interaktion mit einem Webserver ausgelegt ist, gibt es andere Konzepte, einen Benutzer zu authentifizieren und längere Sessions zu ermöglichen.
\subsection{Authentifizierung}
Authentifizierung mittels Cookies, Login-Daten, ..
\subsection{Verschlüsselung}
HTTPS, Verschlüsselung des Passworts (in Datenbanken)
\subsection{Validierung}
Ein kritischer Punkt im Bezug auf die Sicherheit von Web-Anwendungen stellt die Schnittstelle zwischen Umgebung und der Anwendung. \cite[S.212]{ebooks:Architekturen} So schreibt das Bundesamt für Sicherheit in der Informationstechnik dazu: "'Alle Daten, die von außen in die Anwendung gelangen, sind zu validieren und zu filtern."'
\cite[S.20]{BSI}

Folgendes Beispiel sei hierzu angeführt: 
In einer fiktiven Anwendung werden zu speichernde Formulareingaben ohne Überprüfung ihres Inhalts in eine Datenbank gespeichert:

\begin{lstlisting}
<?php
$con = mysqli_connect($host,$username,$password,$dbname);
// Check connection
if (mysqli_connect_errno()) {
  echo "Failed to connect to MySQL: " . mysqli_connect_error();
}

// Get Post Parameters, unfiltered
$firstname = $_POST['firstname'];
$lastname = $_POST['lastname'];
mysqli_query($con,"INSERT INTO Persons (FirstName, LastName)
VALUES ($firstname, $lastname)");

mysqli_close($con);
?>
\end{lstlisting}

Angenommen, ein Angreifer würde (richtig) vermuten, dass die Daten zur Registrierung in einer Tabelle mit Namen "'user"' gespeichert werden, könnte er mit folgender Eingabe in das Formularfeld "'Last Name"' den gesamten Tabelleninhalt löschen:
\begin{lstlisting}
x");TRUNCATE TABLE user; CREATE TABLE prank(id int(9)
\end{lstlisting}
Die Erzeugung einer neuen Tabelle dient hier nur dem Umgehen eines SQL Syntax-Errors wegen der noch ausstehenden schließenden Klammer.
Dieses Beispiel stellt lediglich eine sehr einfache Angriffsmöglichkeit dar, vor die in jedem Grundlagenbuch über PHP gewarnt wird. Eine leichte Abhilfe bietet hierfür die folgende Funktion, indem sie alle speziellen Zeichen im SQL-Syntax "'entschärft"'.
\begin{lstlisting}
string mysqli_real_escape_string(string $escapestr)
\end{lstlisting}

An dieser Stelle bietet das Symfony Framework Abhilfe, in dem die "'HTTP Foundation"' Komponente alle Eingabedaten filtert und je nach Bedarf auch in entsprechende Typen umwandelt.\cite{sf2:HTTPFoundation}

\section{Caching}
Chaching findet auf Browser-Ebene, mit Hilfe von Proxy-Servern und durch Gateway-Caching (Reverse-Proxy) statt.

\section{Exception Handling}
Darstellung von Catchable Errors, verhalten der Applikation im Fehlerfall.


% ***** chapter 4 *****
\chapter{Softwarearchitektur des Symfony 2 Frameworks}
\label{sec:symfony}
Im Folgenden soll ein Überblick über die Softwarearchitektur des Symfony 2 Frameworks gegeben werden.
\section{Seperation of concerns / Component based Framework}
Grundlegend ist die Idee, alle Teile des Frameworks möglichst so voneinander zu trennen, dass sie auch unabhängig voneinander verwendet werden können.
\section{Dependency-Injection / Container Pattern}
Ein Container verbirgt alle technischen Details vor der eigentlichen Implementierung der Software
\section{Verwendete Design-Patterns}
Diese Liste soll keinen Anspruch auf Vollständigkeit erheben, es sollen lediglich beispielhaft die Verwendung einiger gängiger Design-Patterns erläutert werden.
\subsection{Decorator}
Decorator Pattern
\subsection{Composite}
Composite Pattern
\subsection{Unit of Work}
Verwendet in Doctrine \cite{ab94} 




% ***** chapter 5 *****
\chapter{Stand der Entwicklung, Ausblick}
Darstellung der bislang erreichten Entwicklungsziele, Ausblick auf weitere notwendige bzw. mögliche Komponenten und Erweiterungen.

\section{Zu implementieren}
\begin{itemize}
\item{Nachrichtensystem}
\item{Suche}
\item{Bilder hochladen}
\item{Passwort rücksetzen}
\item{email verifikation}
\item{profil von teams}
\end{itemize}

**** umbedingt noch die routing-Tabellen aufteilen und den Dateinamen von listing 3.1 entsprechend ändern ****


\section{Zu Verbesserndes}

\begin{itemize}
\item{Bereinigung der Namen (TeamRace => Teamrace)}
\item{Einheitliche Verwendung vom yml Konfigurationsdateiformat}
\end{itemize}

\section{Weitere Technologien}

\subsection{AJAX}
\label{sec:AJAX}

\bibliographystyle{plain}

\bibliography{bibtex}
\end{document}